import { Injectable } from '@angular/core';
import { BehaviorSubject, Subject } from 'rxjs';
import { Vital } from './vitals/vitals/vital.model';

export interface Preset {
  name: string;
  // slot assignments as vital names or null (length 5)
  slots: (string | null)[];
}

@Injectable({
  providedIn: 'root'
})
export class PresetsService {
  private presets: Preset[] = [];
  private currentIndex$ = new BehaviorSubject<number>(0);
  // emits when the navbar requests a save (click on name)
  private saveRequests = new Subject<void>();
  // whether the current layout has unsaved changes
  private dirty$ = new BehaviorSubject<boolean>(false);
  // display name for the navbar (either preset name or 'New Preset *')
  private displayName$ = new BehaviorSubject<string>('');

  constructor() {
    // default preset: ABP large, below: SpO2, HR, RR, TCore
    this.presets = [
      {
        name: 'Default',
        slots: ['ABP', 'SpO2', 'HR', 'RR', 'TCore']
      }
    ];
    // initialize display name
    this.displayName$.next(this.presets[0].name);
  }

  getPresets(): Preset[] {
    return this.presets;
  }

  getCurrentIndex$() {
    return this.currentIndex$.asObservable();
  }

  // Component(s) can subscribe to this to get save requests from the UI (navbar)
  getSaveRequests$() {
    return this.saveRequests.asObservable();
  }

  getDisplayName$() {
    return this.displayName$.asObservable();
  }

  getDirty$() {
    return this.dirty$.asObservable();
  }

  getCurrentPreset(): Preset {
    return this.presets[this.currentIndex$.value];
  }

  next(): void {
    const nextIdx = (this.currentIndex$.value + 1) % this.presets.length;
    this.currentIndex$.next(nextIdx);
    this.dirty$.next(false);
    this.displayName$.next(this.presets[nextIdx].name);
  }

  prev(): void {
    const prevIdx = (this.currentIndex$.value - 1 + this.presets.length) % this.presets.length;
    this.currentIndex$.next(prevIdx);
    this.dirty$.next(false);
    this.displayName$.next(this.presets[prevIdx].name);
  }

  select(index: number): void {
    if (index >= 0 && index < this.presets.length) {
      this.currentIndex$.next(index);
      this.dirty$.next(false);
      this.displayName$.next(this.presets[index].name);
    }
  }

  savePreset(name: string, slots: (Vital | null)[]): void {
    const slotNames = slots.map(s => s ? s.vitalName : null);
    const newPreset: Preset = { name: name || `Preset ${this.presets.length + 1}`, slots: slotNames };
    this.presets.push(newPreset);
    this.currentIndex$.next(this.presets.length - 1);
    this.dirty$.next(false);
    this.displayName$.next(newPreset.name);
  }

  /** Save current slots as a new preset with an autogenerated name */
  savePresetFromSlots(slots: (Vital | null)[]): void {
    const name = `Preset ${this.presets.length + 1}`;
    this.savePreset(name, slots);
  }

  // UI requests a save (e.g. navbar). MainComponent should subscribe and perform the actual save
  requestSave() {
    this.saveRequests.next();
  }

  // mark that layout changed and that current preset is dirty
  markDirty() {
    this.dirty$.next(true);
    this.displayName$.next('Untitled*');
  }

  clearDirty() {
    this.dirty$.next(false);
    this.displayName$.next(this.getCurrentPreset().name);
  }
}
